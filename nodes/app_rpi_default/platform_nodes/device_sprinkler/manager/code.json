{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "078a6e76-f623-4ae7-8681-f672b2a23c8a",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = device_input_node:Qmf8392h3298h\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n\n      // let dataNode = {\n      //   type: 'device_input_node:Qmf8392h3298h',\n      //   data: {\n      //     deviceNode: deviceNode,\n      //     inputNode: {\n      //       type: 'standard_device_action:Qm2398fhsnsf',\n      //       data: {\n      //         action: 'startup',\n      //         options: {}\n      //       }\n      //     }\n      //   }\n      // }\n      \n      // Load the \"Devices\" capability\n      \n      let cmdInputNode = INPUT.data.inputNode;\n\n      if(cmdInputNode.type != 'standard_device_action:Qm2398fhsnsf'){\n        console.log('Unexpected input schema for device input');\n        return reject('Unexpected input schema for device input');\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      \n      \n      // Acts similar to \"incoming_from_uni\" \n      // - handles all(?) requests to the device \n      //   - usually passes off to another function \n      \n      // Get settings for device \n      // - expecting consistent relative location \n      let thisNode = await universe.searchMemory({\n        filter: {\n          dataFilter: {\n            _id: SELF._id,\n          }\n        }\n      });\n      thisNode = thisNode[0];\n      let deviceNode = thisNode.parent.parent;\n      let settingsNode = universe.lodash.find(deviceNode.nodes,{type: 'settings:Qmf329ffhj9f823h'});\n      if(!settingsNode){\n        console.error('Missing settings for device', deviceNode.data.name);\n        return reject({});\n      }\n      \n      \n      function updateDeviceStatus(newStatus){\n        // update status of deviceNode\n        console.log('Updating status');\n        return new Promise(async (resolve,reject)=>{\n          let updateNode = {\n            _id: deviceNode._id,\n            data: Object.assign(deviceNode.data,{status: newStatus})\n          }\n          await universe.updateNode(updateNode);\n          console.log('Updated device status:', deviceNode.data.name, newStatus);\n          resolve();\n        });\n      }\n      \n      // cache for device code, serialport, etc. \n      universe.globalCache.deviceCache = universe.globalCache.deviceCache || {};\n      let deviceCache = universe.globalCache.deviceCache[deviceNode._id] || {};\n      \n      universe.globalCache.ports = universe.globalCache.ports || {};\n      \n      // Actions \n    \n      switch(inputAction){\n        case 'startup':\n          // check for existence of speaker, play a sound \n          console.log('Startup sprinkler');\n          // new Sound({\n          //   device: settingsNode.data.address,\n          // }).play('/usr/share/sounds/alsa/Front_Center.wav');\n          return resolve({\n            type: 'boolean:Qmdsfdlkj',\n            data: true\n          });\n          break;\n          \n        case 'input':\n          // got some type of input\n          console.log('inputOpts:', JSON.stringify(inputOpts.action,null,2));\n          switch(inputOpts.action){\n            // case 'on':\n            // case 'off':\n            case 'set':\n              \n              let portName = '/dev/ttyUSB0';\n              var port = universe.globalCache.ports[portName]; //deviceCache.port; \n              if(!port){\n                console.log('Creating new SerialPort for sprinkler');\n                var SerialPort = universe.require('serialport');\n                port = new SerialPort(portName, {\n                  baudRate: 9600,\n                  autoOpen: true\n                });\n                // deviceCache.port = port;\n                universe.globalCache.ports[portName] = port;\n              }\n              \n              // Open errors will be emitted as an error event\n              port.on('error', function(err) {\n                console.log('Sprinkler/Relay SerialPortError: ', err.message);\n              })\n              \n              var relayNum = parseInt(inputOpts.data.relay,10); //.data.relayNum.toString(); //(process.argv[2] || '').toString();\n              var cmd = inputOpts.data.status == 'on' ? true:false; //INPUT.data.enable ? true : false; //process.argv[3] || '';\n              \n              // 1: No LED (off, default)\n              // echo -n -e '\\xA0\\x01\\x00\\xA1' > /dev/ttyUSB0\n              \n              // 1: LED (on)\n              // echo -n -e '\\xA0\\x01\\x01\\xA2' > /dev/ttyUSB0\n              \n              // 2: No LED (off, default)\n              // echo -n -e '\\xA0\\x02\\x00\\xA2' > /dev/ttyUSB0\n              \n              // 2: LED (on)\n              // echo -n -e '\\xA0\\x02\\x01\\xA3' > /dev/ttyUSB0\n              console.log('relayNum:', relayNum, 'cmd', cmd);\n              switch(relayNum){\n                case 0:\n                  switch(cmd){\n                    case true: // on\n                      port.write(Buffer.from('A00101A2','hex'));\n                      port.drain();\n                      await updateDeviceStatus('on');\n                      break;\n                    case false: // off\n                      port.write(Buffer.from('A00100A1','hex'));\n                      port.drain();\n                      await updateDeviceStatus('off');\n                      break;\n                    default:\n                      console.log('\"on\" or \"off\" required');\n                      break;\n                  }\n                  break;\n              \n                case 1:\n                  switch(cmd){\n                    case true: // on\n                      port.write(Buffer.from('A00201A3','hex'));\n                      port.drain();\n                      break;\n                    case false: // off\n                      port.write(Buffer.from('A00200A2','hex'));\n                      port.drain();\n                      break;\n                    default:\n                      console.log('\"on\" or \"off\" required');\n                      break;\n                  }\n                  break;\n              \n                default:\n                  console.log('Missing relay number');\n                  break;\n              }\n              \n              // universe.setTimeout(()=>{\n              //   port.close();\n              // },250)\n              \n              console.log('Completed relay set');\n              return resolve({\n                type: 'boolean:Qlfj',\n                data: true\n              });\n            default:\n              console.log('Unhandled inputOpts.action type:', inputOpts.action);\n              break;\n              \n          }\n          return resolve({\n            type: 'boolean:Qmdsfdlkj',\n            data: true\n          });\n          break;\n          \n        default:\n          console.error('Invalid action type:', inputAction);\n          return reject({});\n      }\n        \n    }catch(err){\n      console.error('err managing device:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}