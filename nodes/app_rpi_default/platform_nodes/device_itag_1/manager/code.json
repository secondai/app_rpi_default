{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "078a6e76-f623-4ae7-8681-f672b2a23c8a",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = device_input_node:Qmf8392h3298h\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n\n      // let dataNode = {\n      //   type: 'device_input_node:Qmf8392h3298h',\n      //   data: {\n      //     deviceNode: deviceNode,\n      //     inputNode: {\n      //       type: 'standard_device_action:Qm2398fhsnsf',\n      //       data: {\n      //         action: 'startup',\n      //         options: {}\n      //       }\n      //     }\n      //   }\n      // }\n      \n      // Load the \"Devices\" capability\n      \n      let cmdInputNode = INPUT.data.inputNode;\n\n      if(cmdInputNode.type != 'standard_device_action:Qm2398fhsnsf'){\n        console.log('Unexpected input schema for device input');\n        return reject('Unexpected input schema for device input');\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      \n      \n      // Acts similar to \"incoming_from_uni\" \n      // - handles all(?) requests to the device \n      //   - usually passes off to another function \n      \n      // Get settings for device \n      // - expecting consistent relative location \n      let thisNode = await universe.searchMemory({\n        filter: {\n          dataFilter: {\n            _id: SELF._id,\n          }\n        }\n      });\n      thisNode = thisNode[0];\n      let deviceNode = thisNode.parent.parent;\n      let settingsNode = universe.lodash.find(deviceNode.nodes,{type: 'settings:Qmf329ffhj9f823h'});\n      if(!settingsNode){\n        console.error('Missing settings for device', deviceNode.data.name);\n        return reject({});\n      }\n      \n      \n      // Commonly used variables \n    \n      // Use a shared, persistent instance of noble \n      var noble = universe.globalCache.noble;\n      universe.globalCache.peripheral = universe.globalCache.peripheral || {};\n      \n      function updateDeviceStatus(newStatus){\n        // update status of deviceNode\n        return new Promise(async (resolve,reject)=>{\n          let updateNode = {\n            _id: deviceNode._id,\n            data: Object.assign({status: newStatus},deviceNode.data)\n          }\n          await universe.updateNode(updateNode);\n          console.log('Updated device status:', deviceNode.data.name, newStatus);\n          resolve();\n        });\n      }\n      // TODO: emit event when status changes? \n      \n      function triggerNewScan(){\n        // expecting to be poweredOn\n        console.log('triggerNewScan for noble (30 second scan)');\n        noble.startScanning([], false);\n        universe.setTimeout(()=>{\n          console.log('Stopping scan after 30 seconds');\n          noble.stopScanning();\n        },30 * 1000);\n      }\n      \n      function StateChange(state) {\n        if (state === 'poweredOn') {\n          //\n          // Once the BLE radio has been powered on, it is possible\n          // to begin scanning for services. Pass an empty array to\n          // scan for all services (uses more time and power).\n          //\n          console.log('State Changed, starting scanning...');\n          triggerNewScan();\n        }\n        else {\n          noble.stopScanning();\n        }\n      }\n      \n      function connectToPeripheral(peripheral){\n        return new Promise(async (resolve,reject)=>{\n          await updateDeviceStatus('connecting');\n          peripheral.connect(async (err)=>{\n            console.log('after connect');\n            if(err){\n              await updateDeviceStatus('error-connecting');\n              console.error(err);\n              reject(err);\n            } else {\n              resolve();\n            }\n          })\n        })\n      }\n      \n      function discoverInfo(peripheral){\n        return new Promise((resolve,reject)=>{\n           peripheral.discoverAllServicesAndCharacteristics((err, services, characteristics) => {\n            if(err){\n              console.error(err);\n              return reject(err);\n            }\n            resolve({\n              services,\n              characteristics\n            });\n          })\n        })\n      }\n      \n      async function Discover(peripheral) {\n        // we found a peripheral, stop scanning\n        // noble.stopScanning();\n        \n        let prefId = peripheral.address; // mac address, \"unique\" to device\n        \n        //\n        // The advertisment data contains a name, power level (if available),\n        // certain advertised service uuids, as well as manufacturer data,\n        // which could be formatted as an iBeacon.\n        //\n        // console.log('found peripheral:', peripheral.advertisement, 'KEYS:', Object.keys(peripheral.advertisement), 'Keys2:', Object.keys(peripheral));\n        \n        // FF:FF:10:14:18:BD\n        \n        console.log('found peripheral:', peripheral.address, peripheral.addressType);\n        \n        if(!universe.globalCache.peripheral[prefId]){\n          universe.globalCache.peripheral[prefId] = { \n            device: peripheral,\n            status: 'disconnected',\n            services: [],\n            characteristics: [],\n            subscriptions: {} // added for subscriptions \n          }; // would work better as a Node \n        }\n        \n        let prefObj = universe.globalCache.peripheral[prefId];\n        \n        peripheral.once('connect',async ()=>{\n          prefObj.status = 'connected'\n          console.log('Update device status to connected');\n          await updateDeviceStatus('connected');\n        })\n        peripheral.once('disconnect',async ()=>{\n          console.log('Disconnected peripheral');\n          prefObj.status = 'disconnected'\n          console.log('Update device status to disconnected');\n          await updateDeviceStatus('disconnected');\n          // try to reconnect?\n          if(settingsNode.data.reconnect){\n            // reconnectToPeripheral()\n            triggerNewScan();\n          }\n        })\n        \n        let matches = [settingsNode.data.address.toUpperCase()];\n      \n        if(matches.indexOf(peripheral.address.toString().toUpperCase()) === -1){\n          // not a match\n          return;\n        }\n        \n        console.log('FOUND iTag!', peripheral.address);\n        \n        let wasConnected = false;\n        \n        switch(prefObj.status){\n          case 'connected':\n            console.log('Already connected');\n            wasConnected = true;\n            break;\n          case 'connecting':\n            // in process of connecting, ignore\n            console.log('already connecting!');\n            return;\n            break;\n          case 'disconnected':\n          default:\n            console.log('Connecting to device...');\n            prefObj.status = 'connecting';\n            await connectToPeripheral(peripheral);\n            break;\n        }\n        \n        if(!wasConnected){\n          console.log('(Re)Discovering Info');\n          let servicesAndChars = await discoverInfo(peripheral);\n          prefObj.services = servicesAndChars.services;\n          prefObj.characteristics = servicesAndChars.characteristics;\n        }\n        \n        // console.log('ServicesAndChars:', JSON.stringify(servicesAndChars.services,null,2));\n        for(let service of prefObj.services){\n          console.log('iTagService:', service.name, service.type, service.uuid);\n        }\n        \n        let notifyChar;\n        for(let characteristic of prefObj.characteristics){\n          console.log('iTagCharacteristic:', characteristic.name, characteristic.type, characteristic.uuid, characteristic.properties );\n          \n          if(characteristic.uuid == 'ffe1'){\n            notifyChar = characteristic;\n          }\n        }\n        \n        if(notifyChar){\n          \n          if(wasConnected){\n            console.log('Not re-subscribing, already connected and subscribed'); \n          } else {\n            console.log('Subscribing to characteristic');\n          \n            notifyChar.on('data', function(data, isNotification) {\n              console.log('Got Data!', data, isNotification);\n              \n              // runRequest \n              runInternalRequest();\n              \n            });\n    \n            // to enable notify\n            notifyChar.subscribe(function(err) {\n              console.log('Starting subscribe for ble button', err);\n            });\n          }\n          \n        } else {\n          console.error('Missing Notification Characteristic expected');\n        }\n        \n        // // if(!wasConnected){\n        //   console.log('Disconnecting after X seconds');\n        //   universe.setTimeout(()=>{\n        //     peripheral.disconnect();\n        //     // prefObj.status = 'disconnected'\n        //     // clear subscriptions \n        //     // - necessary to re-subscribe on re-connect?\n        //     //   - might happen automatically? \n        //     // for(prefObj.subscriptions\n        //   },60 * 1000);\n        // // } else {\n        // //   // console.log('Disconnecting...');\n        // //   // peripheral.disconnect();\n        // //   // prefObj.status = 'disconnected';\n        // // }\n       \n      \n      }\n      \n      async function runInternalRequest(){\n        // triggers something internally \n        \n        try {\n          // Handle input from a device \n          // - expecting output via \"httpResponse\" (responseFunc)\n          //  - or, runRequest should return a valid response? \n          let reqNode = {\n            type: 'incoming_device_input:Qmsdlfkj32j900',\n            data: {\n        \t\t\tdeviceId: deviceNode._id,\n        \t\t\taction: 'button-press',\n        \t\t\tdata: {}\n            }\n      \t\t}\n      \t\t\n      \t\t// response is handled by httpResponse \n          let deviceResponse = await universe.runRequest(reqNode, true);\n          \n          console.log('deviceResponse:', deviceResponse);\n          \n        }catch(err){\n          console.error('Failed device input request (runRequest failed):', err);\n        }\n      }\n      \n      \n      switch(inputAction){\n        case 'startup':\n          // \"on boot\" action (when rpi starts up) \n          // - try and connect to iTag \n          // - be respectful of multiple bluetooth connections (instances of noble) \n          //   - have a locking mechanism? (\"I'm lockng across XY axis, for Z period of time\") \n          //   - lock using SELF._id as key? \n          \n          // cache for this codeNode's instance of noble \n          universe.globalCache.codeCache = universe.globalCache.codeCache || {};\n          let codeCache = universe.globalCache.codeCache[SELF._id] || {};\n            \n          if(!noble){\n            // setup noble \n            // - assign to Shared, Persistent modules cache \n            // - only a single instance allowed (but can be shared) \n            noble = universe.require('noble');\n            universe.globalCache.noble = noble;\n            \n          }\n          \n          if(codeCache._StateChange){      \n            noble.removeListener('stateChange', codeCache._StateChange);\n            noble.removeListener('discover', codeCache._Discover);\n          }\n          \n          codeCache._StateChange = StateChange;\n          codeCache._Discover = Discover;\n          \n          if(settingsNode.data.connect_on_startup){\n            console.log('Connecting on startup');\n            \n            noble.on('stateChange', codeCache._StateChange)\n            noble.on('discover', codeCache._Discover)\n            \n            // noble.stopScanning();\n            \n            if(noble.state == 'poweredOn'){\n              triggerNewScan();\n            } else {\n              console.log('noble NOT poweredOn');\n              await updateDeviceStatus('disconnected');\n            }\n            \n          }\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n\n          break;\n          \n        case 'attempt-reconnect':\n          // try reconnecting to device \n          break;\n          \n        case 'disconnect':\n          // disconnect device \n          break;\n          \n        case 'destroy':\n          // remove everything related to device (nodes, etc?) \n          break;\n          \n        case 'input':\n          // got input from a device, via incoming_from_uni\n          // - handle action \n          console.log('device input');\n          \n          // play a sound \n          // - TODO: load generic Sound capability \n          //   - loads a \"has Sound Output\" device, plays a sound \n          // - CURRENT: runs device command \n          \n          try {\n            // Handle input from a device \n            // - expecting output via \"httpResponse\" (responseFunc)\n            //  - or, runRequest should return a valid response? \n            let reqNode = {\n              type: 'incoming_device_input:Qmsdlfkj32j900',\n              data: {\n          \t\t\tdeviceId: '5b34640aa53c1c001c75eed2', //deviceNode._id,\n          \t\t\taction: 'play-wav',\n          \t\t\tdata: {}\n              }\n        \t\t}\n        \t\t\n        \t\t// response is handled by httpResponse \n            let speakerResponse = await universe.runRequest(reqNode, true);\n            \n            console.log('speakerResponse:', speakerResponse);\n            \n          }catch(err){\n            console.error('Failed speakerResponse.playWav input request (runRequest failed):', err);\n          }\n          \n          return resolve({\n            type: 'device_output:Qmdslfj',\n            data: {}\n          });\n          break;\n          \n        default:\n          console.error('Only \"setup\" enabled for Devices');\n          return reject({});\n      }\n        \n    }catch(err){\n      console.error('err managing device:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}