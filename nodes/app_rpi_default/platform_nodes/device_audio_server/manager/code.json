{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "078a6e76-f623-4ae7-8681-f672b2a23c8a",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = device_input_node:Qmf8392h3298h\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n\n      // let dataNode = {\n      //   type: 'device_input_node:Qmf8392h3298h',\n      //   data: {\n      //     deviceNode: deviceNode,\n      //     inputNode: {\n      //       type: 'standard_device_action:Qm2398fhsnsf',\n      //       data: {\n      //         action: 'startup',\n      //         options: {}\n      //       }\n      //     }\n      //   }\n      // }\n      \n      // Load the \"Devices\" capability\n      \n      let cmdInputNode = INPUT.data.inputNode;\n\n      if(cmdInputNode.type != 'standard_device_action:Qm2398fhsnsf'){\n        console.log('Unexpected input schema for device input');\n        return reject('Unexpected input schema for device input');\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      \n      \n      // Acts similar to \"incoming_from_uni\" \n      // - handles all(?) requests to the device \n      //   - usually passes off to another function \n      \n      // Get settings for device \n      // - expecting consistent relative location \n      let thisNode = await universe.searchMemory({\n        filter: {\n          dataFilter: {\n            _id: SELF._id,\n          }\n        }\n      });\n      thisNode = thisNode[0];\n      let deviceNode = thisNode.parent.parent;\n      let settingsNode = universe.lodash.find(deviceNode.nodes,{type: 'settings:Qmf329ffhj9f823h'});\n      if(!settingsNode){\n        console.error('Missing settings for device', deviceNode.data.name);\n        return reject({});\n      }\n      \n      // Load credentials for services \n      // - spotify \n      // - soundcloud (todo) \n      \n      let spotifyCredsNode = await universe.searchMemory({\n        filter: {\n          dataFilter: {\n            type: {\n              $like: 'credentials_spotify:'\n            }\n          }\n        }\n      });\n      spotifyCredsNode = spotifyCredsNode.length ? spotifyCredsNode[0]:null;\n      \n      var fs = universe.require('fs');\n      const path = universe.require('path');\n      const { exec, spawn } = universe.require('child_process');\n      \n      let doneCanWipe;\n      \n      const Mopidy = universe.require('mopidy');\n      var mopidy = universe.sharedServices.mopidy;\n      if(!mopidy){\n        var consoleOutput = function(msg){console.log('mopidy: ', msg ? msg.toString():'cantstringifymsg');}\n        mopidy = new Mopidy({\n          webSocketUrl: \"ws://127.0.0.1:6680/mopidy/ws/\",\n          console: {\n            log: consoleOutput,\n            info: consoleOutput,\n            warn: consoleOutput,\n            error: consoleOutput,\n            debug: consoleOutput\n          }\n        });     \n        universe.sharedServices.mopidy = mopidy;\n        // Connect to server\n        // mopidy.on(console.log.bind(console));  // Log all events\n        mopidy.on(\"state:online\", async ()=>{\n          console.log('===MOPIDY IS ONLINE===');\n        });\n      } \n        \n      var mopidyConfigPath = path.resolve(universe.staticFilePath + '/mopidy.conf');\n    \n      switch(inputAction){\n        case 'startup':\n          // checks for mopidy, starts if not exists \n          // - TODO: allow any service to replace this easily? \n          console.log('Audio Server (mopidy) startup (update /etc/asound.conf, create Mopidy config file, start mopidy)');\n          \n          var asoundConfFile = `          \npcm.!default {\n    type plug\n    slave.pcm \"dmixer\"\n}\npcm.dsp0 {\n    type plug\n    slave.pcm \"dmixer\"\n}\npcm.dmixer {\n    type dmix\n    ipc_key 1024\n    ipc_key_add_uid false\n    ipc_perm 0666 # mixing for all users\n    slave {\n        pcm \"hw:0,0\"\n     }\n     bindings {\n        0 0\n        1 1\n     }\n}\nctl.mixer0 {\n    type hw\n    slave.pcm \"dmixer\"\n}\n`;\n\n          // /etc/asound.conf (dmix mixer to use multiple audio streams) \n          fs.writeFileSync('/etc/asound.conf', asoundConfFile);\n          \n        \n          let configTemplate = `\n[mpd]\nhostname = ::\n\n[audio]\noutput = alsasink device=plug:dmix\n\n[file]\nenabled = true\nmedia_dirs =\n    /usr/src/staticfiles|static\n\n[spotify]\nenabled = true\nusername = ${spotifyCredsNode.data.username}\npassword = ${spotifyCredsNode.data.password}\nclient_id = ${spotifyCredsNode.data.client_id}\nclient_secret = ${spotifyCredsNode.data.client_secret}\n`\n          fs.writeFileSync(mopidyConfigPath, configTemplate);\n          \n          // Start mopidy\n          console.log('Audio Server is Setup (starting child_process)');\n          \n          console.log('Starting mopidy server (spawn child process)'); \n          const mopidyProcess = spawn('mopidy', ['--config', mopidyConfigPath], {shell: true});\n          \n          mopidyProcess.on('error', (err)=>{\n            console.log('mopidyProcess error:', err);\n          })\n          \n          mopidyProcess.stdout.on('data', (data) => {\n            console.log(`mopidy stdout:\\n${data}`);\n          });\n          \n          mopidyProcess.stderr.on('data', (data) => {\n            console.log(`mopidyProcess stderr: ${data}`);\n          });\n          \n          mopidyProcess.on('close', (code) => {\n            console.log(`mopidyProcess child process exited with code ${code}`);\n          });\n          \n          // universe.setTimeout(()=>{\n          //   console.log('KILLING MOPIDY');\n          //   mopidyProcess.kill();\n          // },180 * 1000);\n          \n          return resolve({\n            type: 'boolean:Qmdsfdlkj',\n            data: true\n          });\n          break;\n          \n        case 'input':\n          // received some input from spotify \n          // - like what? input=\"from device\" while action=\"do to device\"\n          \n          return resolve({\n            type: 'boolean:Qmdsfdlkj',\n            data: true\n          });\n          break;\n          \n        case 'action':\n          // running some action \n          console.log('Runing Audio Server action:', JSON.stringify(inputOpts,null,2));\n          \n          switch(inputOpts.action){\n            case 'start-server':\n              // starts mopidy as a child process \n              \n              // console.log('Starting mopidy server (spawn child process)'); \n              // const mopidyProcess = spawn('mopidy', ['--config', mopidyConfigPath], {shell: true});\n              \n              // mopidyProcess.on('error', (err)=>{\n              //   console.log('mopidyProcess error:', err);\n              // })\n              \n              // mopidyProcess.stdout.on('data', (data) => {\n              //   console.log(`mopidy stdout:\\n${data}`);\n              // });\n              \n              // mopidyProcess.stderr.on('data', (data) => {\n              //   console.log(`mopidyProcess stderr: ${data}`);\n              // });\n              \n              // mopidyProcess.on('close', (code) => {\n              //   console.log(`mopidyProcess child process exited with code ${code}`);\n              // });\n              \n              // universe.setTimeout(()=>{\n              //   console.log('KILLING MOPIDY');\n              //   mopidyProcess.kill();\n              // },180 * 1000);\n              \n              // exec(`mopidy --config ${mopidyConfigPath}`, {timeout: 20 * 1000}, (err, stdout, stderr) => {\n              //   if (err) {\n              //     console.error(`exec error: ${err}`);\n              //     return;\n              //   }\n              \n              //   console.log(`mopidy output: ${stdout}`);\n              // });\n              \n              // exec(`which mopidy`, {timeout: 20 * 1000}, (err, stdout, stderr) => {\n              //   if (err) {\n              //     console.error(`exec error: ${err}`);\n              //     return;\n              //   }\n              \n              //   console.log(`mopidy output: ${stdout}`);\n              // });\n              \n              return resolve({\n                type: 'boolean:Qmdsfljk',\n                data: true\n              });\n              \n              \n            // tracks, albums, playlists, etc. \n            case 'spotify-search-tracks':\n              // expecting a node for finding tracks \n              // - what to search is included in node? \n              \n              // get library?\n              // let lib = await mopidy.library.browse(null);\n              // console.log('Libraryies:', lib);\n              \n              // inputOpts.data.type = 'spotify-search-input'\n              var searchQuery = inputOpts.data.data || {'any': ['do you belive in life after love']};\n              \n              // var lib = await mopidy.library.browse('spotify:directory');\n              // console.log('Spotify Library Directory:', lib);\n              console.log('searchQuery:', searchQuery);\n              \n              var tracksResult = await mopidy.library.search(searchQuery, uris=['spotify:'])\n              if(!tracksResult.length){\n                console.error('Failed finding tracks');\n                return;\n              }\n              \n              return resolve({\n                type: 'spotify-search-result:Qmsdflj',\n                data: {\n                  tracks: tracksResult[0].tracks\n                }\n              });\n              \n              \n            case 'play-track':\n              // track should be a node w/ URI included\n              // console.log('tracks:', tracksResult[0].tracks.length);\n              // let track = tracksResult[0].tracks[0];\n              // console.log('track:', track);\n              \n              // inputOpts.data.type == 'track-by-uri'\n              var trackUri = inputOpts.data.data.uri;\n              \n              // play track (queue and play) \n              // let playlists = await mopidy.playlists.getPlaylists();\n              // console.log('Playlist:', playlists);\n              await mopidy.tracklist.clear();\n              let tlTracks = await mopidy.tracklist.add(null,null,trackUri);\n              await mopidy.playback.play(tlTracks[0]);\n              await mopidy.playback.getCurrentTrack();\n              console.log('Playing track?');\n              \n              // announce \"doing\" along with an ID of the \"conversation\" (way of interrupting) \n              \n              return resolve({\n                type: 'boolean:Qmdsfljk',\n                data: true\n              });\n              \n            \n            default:\n              console.log('Unhandled inputOpts.action type:', inputOpts.action);\n              break;\n              \n          }\n          return resolve({\n            type: 'boolean:Qmdsfdlkj',\n            data: true\n          });\n          break;\n          \n        default:\n          console.error('Invalid action type:', inputAction);\n          return reject({});\n      }\n        \n    }catch(err){\n      console.error('err managing device:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}