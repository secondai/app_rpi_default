{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "persistent": true,
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "note": "Capability: Devices",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Devices\" capability\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      universe.globalCache.codeCache = universe.globalCache.codeCache || {};\n      if(!universe.globalCache.codeCache[SELF._id]){\n        universe.globalCache.codeCache[SELF._id] = {};\n      }\n      let codeCache = universe.globalCache.codeCache[SELF._id];\n      \n      let doneCanWipe;\n      \n      switch(inputAction){\n        case 'setup':\n          \n          console.log('Setting up Devices');\n          \n          // Find Devices \n          // ForEach Device\n          // - run device startup (run DeviceManager code) \n          let devices = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                type: {\n                  $like: 'device:'\n                }\n              },\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return universe.sameAppPlatform(SELF, tmpNode)\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          for(let deviceNode of devices){\n            let deviceName = deviceNode.data ? deviceNode.data.name:'unknown';\n            console.log('Setup Device:', deviceName);\n            let managerNode = universe.lodash.find(deviceNode.nodes,{type: 'device_manager:Qmdslfkj23ff'});\n            if(!managerNode){\n              console.error('Missing Manager for device', deviceNode._id);\n              continue;\n            }\n            let codeNode = universe.lodash.find(managerNode.nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            if(!codeNode){\n              console.error('Missing CodeNode for Managaer for device', deviceNode._id);\n              continue;\n            }\n            \n            let dataNode = {\n              type: 'device_input_node:Qmf8392h3298h',\n              data: {\n                deviceNode: deviceNode,\n                inputNode: {\n                  type: 'standard_device_action:Qm2398fhsnsf',\n                  data: {\n                    action: 'startup',\n                    options: {}\n                  }\n                }\n              }\n            }\n            \n            try{\n              let deviceStartupResult = await universe.runNodeCodeInVM({\n                codeNode, // includes type/schemaName and data \n                dataNode //INPUT_data.dataForAction, // should be another Node that can be used by the action! \n                // timeout: 25 * 1000\n              });\n              console.log('DeviceStartupResult:', deviceNode._id, deviceName, universe.cJSON.stringify(deviceStartupResult));\n            }catch(err){\n              console.error('Failed device setup:', deviceNode._id, deviceName);\n            }\n          }\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n\n          \n        \n        case 'setupAllExternalSyncs':\n          // used on startup, syncs all local devices (NOT emulated devices?) with external \n          // - prevent \"resyncing\" where the remote is the actual owner (and I/cloud would have a managed version) \n        \n          // for each ExternalIdentity w/ a \"managed_devices\" node type\n          //- for each device, subscribe to state changes (changes to Device's node, or also watch for state changes?), sync changes to remote Sync as well \n          console.log('setupAllExternalSyncs');\n          \n          // exiting if called again \n          universe.wipeFunc = new Promise(resolve=>{\n            doneCanWipe = resolve;\n          });\n          \n          // Find Devices\n          var deviceNodes = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                type: {\n                  $like: 'device:'\n                }\n              },\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return universe.sameAppPlatform(SELF, tmpNode)\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          // Each device has a unique id, NOT the Node._id, but Node.data.uuid \n          var uuidToDevice = {};\n          deviceNodes.forEach(deviceNode=>{\n            console.log('deviceNode uuid/name:', deviceNode.data.uuid, deviceNode.data.name);\n            uuidToDevice[deviceNode.data.uuid] = deviceNode;\n          });\n          \n          // Find External Identities (that also manage devices) \n          var externalIdentitiesForDevices = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                nodeId: null,\n                type: {\n                  $like: 'external_identity:'\n                },\n                nodes: {\n                  $elemMatch: {\n                    type: {\n                      $like: 'device_sync_info:'\n                    }\n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('ExternalIdentities to sync devices:', externalIdentitiesForDevices.length);\n          \n          // iterate over Externals \n          for(let ExternalIdentityNode of externalIdentitiesForDevices){\n            // Iterate over the devices that should be available/known to the remote \n            // - stored as devices in ExternalIdentity.nodes type=\"devices_synced_to_remote\" child nodes\n            // let devicesToSyncFolder = universe.lodash.find(ExternalIdentityNode.nodes,{ // Folder is unnecessary \n            //   type: 'devices_synced_to_remote:Qmsdfkljdsf'\n            // });\n            // if(!devicesToSyncFolder){\n            //   // not syncing devices to this ExternalIdentity \n            //   continue;\n            // }\n            \n            let devicesToSync = universe.lodash.filter(ExternalIdentityNode.nodes,{\n              type: 'device_sync_info:Qmf329h23f324f43dsfcx'\n            });\n            \n            // Subscribe to local changes of the device state (TODO: capabilities, etc.) \n            // - state is stored in nodes, or as a json object? (TODO: store as nodes [more future-proof/flexible], single is easier for initial setup/testing) \n            // - updates the remote as well (update_managed_device_state:...)\n            for(let relatedDeviceNode of devicesToSync){\n              // trigger sync \n              // - remote handles creation/update (for now) \n              \n              let DeviceNode = uuidToDevice[relatedDeviceNode.data.uuid];\n              if(!DeviceNode){\n                console.error('Missing DeviceNode for relatedDeviceNode', relatedDeviceNode.data.uuid);\n                continue;\n              }\n              \n              // // parallel! (no waiting for success) \n              // console.log('Triggering syncing device state');\n              // universe.loadAndRunCapability('Devices',{},{\n              //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n              //   data: {\n              //     action: 'syncDeviceToRemote',\n              //     options: {\n              //       DeviceNode,\n              //       ExternalIdentityNode\n              //     }\n              //   }\n              // });\n              \n              // setup listen for changes to state of device \n              // - remove existing listeners (stored in code cache?) \n              var listenerKey = `listeners-${DeviceNode._id}`;\n              console.log('listenerKey', listenerKey);\n              if(codeCache[listenerKey]){\n                universe.eventEmitter.removeListener(`node-modified-${DeviceNode._id}`, codeCache[listenerKey]);\n              } else {\n                // console.log('codeCache does NOT exist, NOTHING to remove');\n              }\n              codeCache[listenerKey] = (updatedNode)=>{\n                \n                  console.log('Syncing after update of node', updatedNode); // type: \"saved_node\" is returned \n                  \n                  // TODO: check for differences before syncing?\n                  // - lastSyncedData ?\n                  // sprinkler\n                   \n                  universe.loadAndRunCapability('Devices',{},{\n                    type: 'standard_capability_action:0.0.1:local:298j291bs',\n                    data: {\n                      action: 'syncDeviceToRemote',\n                      options: {\n                        DeviceNode: updatedNode.data,\n                        ExternalIdentityNode\n                      }\n                    }\n                  });\n                  \n              };\n              universe.eventEmitter.on(`node-modified-${DeviceNode._id}`, codeCache[listenerKey]);\n                \n            }\n            \n          }\n          \n          // // remove previous listener (or memory leak, duplicate/stale events) ? (doesnt work to do this) \n          // if(universe.lodash.isFunction(codeCache.existingSetupDoneCanWipe)){\n          //   codeCache.existingSetupDoneCanWipe();\n          // }\n          // codeCache.existingSetupDoneCanWipe = doneCanWipe();\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n          \n          \n        case 'syncDeviceToRemote':\n          // Sync a local device to remote \n          // - could be triggered by startup, an update, etc. \n          \n          // TODO: check for differences before syncing?\n          // - lastSyncedData ?\n          \n          console.log('syncDeviceToRemote initiated');\n          \n          // inputOpts.DeviceNode, inputOpts.ExternalIdentityNode\n          if(!inputOpts.DeviceNode || !inputOpts.ExternalIdentityNode){\n            console.error('Missing DeviceNode or ExternalIdentityNode from inputOpts!');\n            return resolve({\n              type: 'error:...',\n              data: 'Missing DeviceNode/ExternalIdentityNode'\n            });\n          }\n          \n          // Expecting inputOpts.DeviceNode to be updated to latest! NOT refetching! \n          \n          let deviceSyncResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode: inputOpts.ExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                      {\n                        matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                        dataForAction: {\n                          type: 'string:...',\n                          data: inputOpts.ExternalIdentityNode.data.token\n                        }\n                      },\n                      {\n                        matchActionType: 'update_managed_device_state:Qmsdflkjl23',\n                        dataForAction: {\n                          type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                          data: {\n                            deviceUuid: inputOpts.DeviceNode.data.uuid,\n                            name: inputOpts.DeviceNode.data.name,\n                            stateData: inputOpts.DeviceNode.data.state || {} \n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('Updated device state:', inputOpts.DeviceNode.data.name);\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n          \n          \n          \n        case 'input':\n          // got input from a device \n          // - pass along data, return response \n          // console.log(JSON.stringify(inputOpts,null,2));\n          \n          // Find Device\n          var deviceNode = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                _id: inputOpts.deviceId\n              },\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return universe.sameAppPlatform(SELF, tmpNode)\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          if(deviceNode.length != 1){\n            console.error('Invalid deviceNode length returned:', deviceNode.length);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'invalid deviceNode internal id'\n              }\n            });\n          }\n          deviceNode = deviceNode[0];\n        \n          var deviceName = deviceNode.data ? deviceNode.data.name:'unknown';\n          console.log('Device for Input:', deviceName);\n          var managerNode = universe.lodash.find(deviceNode.nodes,{type: 'device_manager:Qmdslfkj23ff'});\n          if(!managerNode){\n            console.error('Missing Manager for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing manager for device'\n              }\n            });\n          }\n          var codeNode = universe.lodash.find(managerNode.nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          if(!codeNode){\n            console.error('Missing CodeNode for Managaer for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing code for manager for device'\n              }\n            });\n          }\n          \n          var dataNode = {\n            type: 'device_input_node:Qmf8392h3298h',\n            data: {\n              deviceNode: deviceNode,\n              inputNode: {\n                type: 'standard_device_action:Qm2398fhsnsf',\n                data: {\n                  action: 'input',\n                  options: inputOpts\n                }\n              }\n            }\n          }\n          \n          try{\n            console.log('Passing to dataInput action');\n            let deviceInputResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode //INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              // timeout: 25 * 1000\n            });\n            console.log('deviceInputResult:', deviceNode._id, deviceName, universe.cJSON.stringify(deviceInputResult));\n          }catch(err){\n            console.error('Failed device input:', deviceNode._id, deviceName, err);\n          }\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n          \n          break;\n          \n          \n        case 'reconnect':\n          // run the dedicated action \n          var deviceNode = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                _id: inputOpts.deviceId\n              },\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return universe.sameAppPlatform(SELF, tmpNode)\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          if(deviceNode.length != 1){\n            console.error('Invalid deviceNode length returned:', deviceNode.length);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'invalid deviceNode internal id'\n              }\n            });\n          }\n          deviceNode = deviceNode[0];\n        \n          var deviceName = deviceNode.data ? deviceNode.data.name:'unknown';\n          console.log('Device for reconnect:', deviceName);\n          var managerNode = universe.lodash.find(deviceNode.nodes,{type: 'device_manager:Qmdslfkj23ff'});\n          if(!managerNode){\n            console.error('Missing Manager for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing manager for device'\n              }\n            });\n          }\n          var codeNode = universe.lodash.find(managerNode.nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          if(!codeNode){\n            console.error('Missing CodeNode for Managaer for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing code for manager for device'\n              }\n            });\n          }\n          \n          var dataNode = {\n            type: 'device_input_node:Qmf8392h3298h',\n            data: {\n              deviceNode: deviceNode,\n              inputNode: {\n                type: 'standard_device_action:Qm2398fhsnsf',\n                data: {\n                  action: 'reconnect',\n                  options: inputOpts\n                }\n              }\n            }\n          }\n          \n          try{\n            console.log('Passing to device reconnect action');\n            let deviceReconnectResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode //INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              // timeout: 25 * 1000\n            });\n            console.log('deviceReconnectResult:', deviceNode._id, deviceName, universe.cJSON.stringify(deviceReconnectResult));\n          }catch(err){\n            console.error('Failed device input:', deviceNode._id, deviceName, err);\n          }\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n          \n          break;\n          \n          \n        case 'disconnect':\n          // run the dedicated action \n          var deviceNode = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                _id: inputOpts.deviceId\n              },\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return universe.sameAppPlatform(SELF, tmpNode)\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          if(deviceNode.length != 1){\n            console.error('Invalid deviceNode length returned:', deviceNode.length);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'invalid deviceNode internal id'\n              }\n            });\n          }\n          deviceNode = deviceNode[0];\n        \n          var deviceName = deviceNode.data ? deviceNode.data.name:'unknown';\n          console.log('Device for disconnect:', deviceName);\n          var managerNode = universe.lodash.find(deviceNode.nodes,{type: 'device_manager:Qmdslfkj23ff'});\n          if(!managerNode){\n            console.error('Missing Manager for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing manager for device'\n              }\n            });\n          }\n          var codeNode = universe.lodash.find(managerNode.nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          if(!codeNode){\n            console.error('Missing CodeNode for Managaer for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing code for manager for device'\n              }\n            });\n          }\n          \n          var dataNode = {\n            type: 'device_input_node:Qmf8392h3298h',\n            data: {\n              deviceNode: deviceNode,\n              inputNode: {\n                type: 'standard_device_action:Qm2398fhsnsf',\n                data: {\n                  action: 'disconnect',\n                  options: inputOpts\n                }\n              }\n            }\n          }\n          \n          try{\n            console.log('Passing to device disconnect action');\n            let deviceDisconnectResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode //INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              // timeout: 25 * 1000\n            });\n            console.log('deviceDisconnectResult:', deviceNode._id, deviceName, universe.cJSON.stringify(deviceDisconnectResult));\n          }catch(err){\n            console.error('Failed device disconnect:', deviceNode._id, deviceName, err);\n          }\n          \n          return resolve({\n            type: 'boolean:Qmsdflkj',\n            data: true\n          });\n          \n          break;\n          \n          \n        case 'action':\n          // sending an action to a device \n          \n          // Find Device\n          var deviceNode = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                _id: inputOpts.deviceId\n              },\n              filterNodes: tmpNodes=>{\n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return universe.sameAppPlatform(SELF, tmpNode)\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          if(deviceNode.length != 1){\n            console.error('Invalid deviceNode length returned:', deviceNode.length);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'invalid deviceNode internal id'\n              }\n            });\n          }\n          deviceNode = deviceNode[0];\n        \n          var deviceName = deviceNode.data ? deviceNode.data.name:'unknown';\n          console.log('Device for Action:', deviceName);\n          var managerNode = universe.lodash.find(deviceNode.nodes,{type: 'device_manager:Qmdslfkj23ff'});\n          if(!managerNode){\n            console.error('Missing Manager for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing manager for device'\n              }\n            });\n          }\n          var codeNode = universe.lodash.find(managerNode.nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          if(!codeNode){\n            console.error('Missing CodeNode for Managaer for device', deviceNode._id);\n            return resolve({\n              type: 'error:Qmdsf',\n              data: {\n                msg: 'Missing code for manager for device'\n              }\n            });\n          }\n          \n          var dataNode = {\n            type: 'device_action_node:Qmf8392h3298h',\n            data: {\n              deviceNode: deviceNode,\n              inputNode: {\n                type: 'standard_device_action:Qm2398fhsnsf',\n                data: {\n                  action: 'action',\n                  options: inputOpts\n                }\n              }\n            }\n          }\n          \n          try{\n            console.log('Passing to device action');\n            let deviceActionResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode //INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              // timeout: 25 * 1000\n            });\n            console.log('deviceActionResult:', deviceNode._id, deviceName, 'ResultType:', deviceActionResult.type);\n            \n            return resolve(deviceActionResult);\n          }catch(err){\n            console.error('Failed device action:', deviceNode._id, deviceName, err);\n            return resolve({\n              type: 'boolean:Qmsdflkj',\n              data: false\n            });\n          }\n          \n          \n          break;\n          \n          \n        default:\n          console.error('Invalid action for capability:', inputAction);\n          return reject({});\n      }\n        \n    }catch(err){\n      console.error('err setting up devices:', err.toString(), err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "508e6e42-51ec-44d6-aa9b-10a912da2ed8"
  }
}