{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "caa31b79-0ffc-417a-b7cc-9ed5d61332a6",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: generic_cloud_second \n      \n      console.log('--Incoming request to app_base incoming_from_uni--');\n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      // console.log('INPUT:', JSON.stringify(INPUT,null,2));\n      \n      \n      switch(INPUT.type){\n          \n        case 'incoming_first:0.1.1:local:78882h37':\n          \n          console.log('Incoming First, after learnBasics');\n          \n          // INPUT is an ExternalIdentityNode\n          // return resolve({\n          //   learning: true,\n          //   INPUT\n          // });\n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          console.log('newIdentityNode', JSON.stringify(newIdentityNode,null,2));\n          \n          \n          // STOPPING HERE! \n          // - not \"learning\" anything from remote, just using whatever is currently available (JSON-start)\n          \n          // console.log('Created Identity on _first, Second all ready!');\n          \n          // // Register Identity on remote \n          // let registeredExternal = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'registerOnChain',\n          //     options: {\n          //       words: universe.env.STARTUP_REACHABLE_WORDS,\n          //       publicKey: newIdentityNode.data.public,\n          //       connection: newIdentityNode.nodes[0].data.connection\n          //     }\n          //   }\n          // });\n          \n          \n          return resolve({\n            type: 'something2...',\n            data: {\n              createdIdentity: true,\n              // registeredExternal\n              // WORDS: universe.env.STARTUP_REACHABLE_WORDS,\n              // publicKey: newIdentityNode.data.public,\n              // connection: newIdentityNode.nodes[0].data.connection\n            }\n          });\n          \n          \n        case 'incoming_startup:Qmf3289h9293fhsb':\n          // Startup/Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          \n          console.log('Incoming Startup/Wakeup');\n          \n          // // Start Scheduler \n          // await universe.loadAndRunCapability('Scheduler',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'start',\n          //     options: {}\n          //   }\n          // });\n          \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n          \n          \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          \n          // console.log('incoming_web_request!!');\n          // return resolve({\n          //   ok: true\n          // });\n              \n          // if(INPUT.type == 'run_action:0.0.1:local:2398y294c23'){\n            // this is the main/expected input\n            \n            // // Get current app_base for this CodeNode \n            // let appBaseNode = await universe.appBaseOf(SELF._id);\n  \n            // try {\n            //   console.log('SEARCH1');\n            //   console.log(SELF._id);\n            //   console.log(SELF.parent._id);\n            //   console.log(SELF.parent.parent._id);\n            //   console.log('SEARCH2');\n            // }catch(err){\n            // }\n            \n            // expecting a full express.req object in INPUT \n            // - headers, paths, body, etc. \n            \n            console.log('--incoming web request--');\n            \n            let expressNode = INPUT.data; // INPUT.data.type == 'express_obj:Qmdsfkljsl'\n            \n            \n            let headers = expressNode.data.req.headers;\n            let body = expressNode.data.req.body;\n            \n            \n            console.log('Path:', expressNode.data.req.path);\n            // console.log('BODY:', JSON.stringify(body,null,2));\n            // console.log('ExpressNode:', universe.cJSON.stringify(expressNode,null,2));\n            \n            \n            // Load routes, controllers for each (TODO) \n            // - MVC-like for web requests, expecting most non-node requests to be authentication one-offs \n            \n            \n            // cache the action code \n            let cacheAppId = universe.getParentRoot(SELF)._id;\n            let cache = ['incoming_web_request_route_nodes', cacheAppId].join('|');\n            \n            // app root-level (old: global-root) \n            let routeNodes = await universe.searchMemory({\n              cache,\n              filter: {\n                sqlFilter: {\n                  // nodeId: null // OLD: root-level\n                  type: 'incoming_route_handler:Qmsdfkj329j3'\n                },\n                // function for returning data from the Node, after filtering a bit \n                // - includes both the Node, and Nodes with nodeId (pointers) \n                filterNodes: tmpNodes=>{\n                  // this runs isolated, outside of the above context? (not sure..think it is same context though [using INPUT.data.type in search]) \n                  return new Promise((resolve, reject)=>{\n                    tmpNodes = tmpNodes.filter(tmpNode=>{\n                      // see if has a ChildNode matching a type \n                      \n                      if(!universe.sameAppPlatform(SELF, tmpNode)){\n                        // console.log('FOUND IT UNDER SAME APP!!!!!', tmpNode._id);\n                        return false;\n                      }\n                      \n                      return true;\n                      \n                    });\n                    resolve(tmpNodes);\n                  });\n                },\n              }\n            });\n            \n            console.log('Sort routes');\n            \n            // prevent \"/ai\" from being pushed to the bottom! \n            // - mucking with /ai will cause some serious problems! \n            \n            let routes = routeNodes.sort((a,b)=>{\n              try {\n                  // multiple /ai's?\n                if(a.data.ai && !b.data.ai){\n                  return -1;\n                }\n                if(b.data.ai && !a.data.ai){\n                  return 1;\n                }\n                return (a.data.priority > b.data.priority) ? 1:-1; // lower priority => checked first!\n              }catch(err){\n                console.error('err sorting routes:', err);\n                return 0;\n              }\n            }).map(routeNode=>{\n              // get codeNode to run \n              let routeTxtMatches = routeNode.data.routes || []; // multiple allowed \n              \n              let routeCodeNodeToRun = universe.lodash.find(routeNode.nodes,{type:'code:0.0.1:local:32498h32f2'});\n              \n              return [routeTxtMatches, routeCodeNodeToRun];\n            });\n            \n            console.log('Checking routes', routes.length);\n            \n            // // print out routes to check (order\n            // for(let route1 of routes){\n            //   console.log('ROUTECheck1:',JSON.stringify(route1[0]));\n            // }\n            \n            let routed = false;\n            for(let route of routes){\n              if(routed){continue}\n              for(let tmpMatchRoute of route[0]){\n                if(routed){continue}\n                let tmpRoute = new universe.RouteParser(tmpMatchRoute);\n                let match = tmpRoute.match(expressNode.data.req.path)\n                if(match){\n                  routed = true;\n                  \n                  console.log('MATCH ROUTE:', match ? true:false, tmpMatchRoute, match);\n                  \n                  // update expressNode with params\n                  expressNode.data.params = match;\n                  \n                  // run in vm, and pass in the inputSchema Node! \n                  // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n                  let routeResult;\n                  try {\n                    console.log('Getting routeResult');\n                    routeResult = await universe.runNodeCodeInVM({\n                      codeNode: route[1], // includes type/schemaName and data \n                      dataNode: expressNode, // passes express obj, with req, res \n                      timeout: 15 * 1000\n                    });\n                  }catch(err){\n                    return resolve('FAILED code from incoming_web_request, trying to run route');\n                  }\n                  \n                  console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n                  return resolve({\n                    type: 'executed_route:Qmmf3290jhgj',\n                    data: true\n                  });\n                  \n                }\n              }\n            }\n            \n            if(!routed){\n              console.log('No Matches');\n              await universe.httpResponse('send','404 - Missing Page');\n              return resolve({\n                type: 'missing_route:Qm404sfhsf',\n                data: false\n              });\n            }\n            \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          break;\n          \n          \n        default:\n          return resolve({\n            type: 'err:..',\n            data: {\n              msg: 'Missing valid input type',\n              INPUT\n            }\n          });\n      }\n\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}